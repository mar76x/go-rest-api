// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: contract.sql

package db

import (
	"context"

	uuid "github.com/google/uuid"
)

const createContract = `-- name: CreateContract :one
INSERT INTO contract
(id, type, start_date, employee_id, company_id, branch_id, area_id, department_id, role_id)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9) RETURNING id, type, start_date, employee_id, company_id, branch_id, area_id, department_id, role_id, created_at, updated_at, deleted_at
`

type CreateContractParams struct {
	ID           int64     `json:"id"`
	Type         string    `json:"type"`
	StartDate    string    `json:"start_date"`
	EmployeeID   uuid.UUID `json:"employee_id"`
	CompanyID    int64     `json:"company_id"`
	BranchID     int64     `json:"branch_id"`
	AreaID       int64     `json:"area_id"`
	DepartmentID int64     `json:"department_id"`
	RoleID       int64     `json:"role_id"`
}

func (q *Queries) CreateContract(ctx context.Context, arg CreateContractParams) (Contract, error) {
	row := q.db.QueryRow(ctx, createContract,
		arg.ID,
		arg.Type,
		arg.StartDate,
		arg.EmployeeID,
		arg.CompanyID,
		arg.BranchID,
		arg.AreaID,
		arg.DepartmentID,
		arg.RoleID,
	)
	var i Contract
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.StartDate,
		&i.EmployeeID,
		&i.CompanyID,
		&i.BranchID,
		&i.AreaID,
		&i.DepartmentID,
		&i.RoleID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteContract = `-- name: DeleteContract :exec
DELETE FROM contract
WHERE id = $1
`

func (q *Queries) DeleteContract(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteContract, id)
	return err
}

const getContract = `-- name: GetContract :one
SELECT id, type, start_date, employee_id, company_id, branch_id, area_id, department_id, role_id, created_at, updated_at, deleted_at FROM contract
WHERE id = $1
`

func (q *Queries) GetContract(ctx context.Context, id int64) (Contract, error) {
	row := q.db.QueryRow(ctx, getContract, id)
	var i Contract
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.StartDate,
		&i.EmployeeID,
		&i.CompanyID,
		&i.BranchID,
		&i.AreaID,
		&i.DepartmentID,
		&i.RoleID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const listContract = `-- name: ListContract :many
SELECT id, type, start_date, employee_id, company_id, branch_id, area_id, department_id, role_id, created_at, updated_at, deleted_at FROM contract
ORDER BY id
LIMIT $1
OFFSET $2
`

type ListContractParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListContract(ctx context.Context, arg ListContractParams) ([]Contract, error) {
	rows, err := q.db.Query(ctx, listContract, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Contract
	for rows.Next() {
		var i Contract
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.StartDate,
			&i.EmployeeID,
			&i.CompanyID,
			&i.BranchID,
			&i.AreaID,
			&i.DepartmentID,
			&i.RoleID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateContract = `-- name: UpdateContract :exec
UPDATE contract
    set type = $2, start_date = $3, employee_id = $4, company_id = $5, branch_id = $6, area_id = $7, department_id = $8, role_id = $9
WHERE id = $1
`

type UpdateContractParams struct {
	ID           int64     `json:"id"`
	Type         string    `json:"type"`
	StartDate    string    `json:"start_date"`
	EmployeeID   uuid.UUID `json:"employee_id"`
	CompanyID    int64     `json:"company_id"`
	BranchID     int64     `json:"branch_id"`
	AreaID       int64     `json:"area_id"`
	DepartmentID int64     `json:"department_id"`
	RoleID       int64     `json:"role_id"`
}

func (q *Queries) UpdateContract(ctx context.Context, arg UpdateContractParams) error {
	_, err := q.db.Exec(ctx, updateContract,
		arg.ID,
		arg.Type,
		arg.StartDate,
		arg.EmployeeID,
		arg.CompanyID,
		arg.BranchID,
		arg.AreaID,
		arg.DepartmentID,
		arg.RoleID,
	)
	return err
}
